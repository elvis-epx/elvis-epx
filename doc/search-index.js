var searchIndex = {};
searchIndex['rexiftool'] = {"items":[],"paths":[]};
searchIndex['rexif'] = {"items":[[0,"","rexif","RExif is a native Rust create, written to extract EXIF data from JPEG and TIFF images.",null,null],[3,"IRational","","Encapsulation of the TIFF type that represents a signed rational number",null,null],[12,"numerator","","",0,null],[12,"denominator","","",0,null],[3,"URational","","Encapsulation of the TIFF type that represents an unsigned rational number",null,null],[12,"numerator","","",1,null],[12,"denominator","","",1,null],[3,"ExifData","","Top-level structure that contains all parsed metadata inside an image",null,null],[12,"mime","","MIME type of the parsed image. It may be \"image/jpeg\", \"image/tiff\", or empty if unrecognized.",2,null],[12,"entries","","Collection of EXIF entries found in the image",2,null],[3,"ExifError","","EXIF parsing error type",null,null],[12,"kind","","The general kind of the error that aborted the parsing",3,null],[12,"extra","","Extra context info about the error, when available",3,null],[3,"IfdEntry","","Structure that represents a parsed IFD entry of a TIFF image",null,null],[12,"tag","","IFD tag value, may or not be an EXIF tag",4,null],[12,"format","","IFD data format",4,null],[12,"count","","Number of items, each one in the data format specified by format",4,null],[12,"data","","Raw data as a vector of bytes. Length is sizeof(format) * count.\nDepending on its size, it came from different parts of the image file.",4,null],[12,"ifd_data","","Raw data contained within the IFD structure. If count * sizeof(format) >= 4,\nthis item contains the offset where the actual data can be found",4,null],[12,"ext_data","","Raw data contained outside of the IFD structure and pointed by ifd_data,\nif data would not fit within the IFD structure",4,null],[12,"le","","If true, integer and offset formats must be parsed from raw data as little-endian\nIf false, integer and offset formats must be parsed from raw data as big-endian",4,null],[3,"ExifEntry","","Structure that represents a parsed EXIF tag.",null,null],[12,"ifd","","Low-level IFD entry that contains the EXIF tag. The client may look into this\nstructure to get tag's raw data, or to parse the tag herself if `tag` is `UnknownToMe`.",5,null],[12,"tag","","EXIF tag type as an enumeration. If `UnknownToMe`, the crate did not know the\ntag in detail, and parsing will be incomplete. The client may read into\n`ifd` to discover more about the unparsed tag.",5,null],[12,"value","","EXIF tag value as an enumeration. Behaves as a \"variant\" value",5,null],[12,"unit","","Unit of the value, if applicable. If tag is `UnknownToMe`, unit will be empty.\nIf the tag has been parsed and it is indeed unitless, it will be `\"none\"`.",5,null],[12,"tag_readable","","Human-readable name of the `tag`, for debugging and listing purposes",5,null],[12,"value_readable","","Human-readable, but simple, version of `value`.\nEnumerations or tuples are not interpreted nor combined. This member contains a\ncorrect data representation even if tag is `UnknownToMe`.",5,null],[12,"value_more_readable","","Human-readable and \"pretty\" version of `value`.\nEnumerations and tuples are interpreted and combined. If `value`\nhas a unit, it is also added. \nIf tag is `UnknownToMe`,\nthis member contains the same string as `value_readable`.",5,null],[4,"ExifErrorKind","","Possible fatal errors that may happen when an image is parsed.",null,null],[13,"FileOpenError","","",6,null],[13,"FileSeekError","","",6,null],[13,"FileReadError","","",6,null],[13,"FileTypeUnknown","","",6,null],[13,"JpegWithoutExif","","",6,null],[13,"TiffTruncated","","",6,null],[13,"TiffBadPreamble","","",6,null],[13,"IfdTruncated","","",6,null],[13,"ExifIfdTruncated","","",6,null],[13,"ExifIfdEntryNotFound","","",6,null],[4,"ExifTag","","Enumeration that represents recognized EXIF tags found in TIFF IFDs.",null,null],[13,"UnknownToMe","","Tag not recognized are partially parsed. The client may still try to interpret\nthe tag by reading into the IfdFormat structure.",7,null],[13,"ImageDescription","","",7,null],[13,"Make","","",7,null],[13,"Model","","",7,null],[13,"Orientation","","",7,null],[13,"XResolution","","",7,null],[13,"YResolution","","",7,null],[13,"ResolutionUnit","","",7,null],[13,"Software","","",7,null],[13,"DateTime","","",7,null],[13,"HostComputer","","",7,null],[13,"WhitePoint","","",7,null],[13,"PrimaryChromaticities","","",7,null],[13,"YCbCrCoefficients","","",7,null],[13,"ReferenceBlackWhite","","",7,null],[13,"Copyright","","",7,null],[13,"ExifOffset","","",7,null],[13,"GPSOffset","","",7,null],[13,"ExposureTime","","",7,null],[13,"FNumber","","",7,null],[13,"ExposureProgram","","",7,null],[13,"SpectralSensitivity","","",7,null],[13,"ISOSpeedRatings","","",7,null],[13,"OECF","","",7,null],[13,"ExifVersion","","",7,null],[13,"DateTimeOriginal","","",7,null],[13,"DateTimeDigitized","","",7,null],[13,"ShutterSpeedValue","","",7,null],[13,"ApertureValue","","",7,null],[13,"BrightnessValue","","",7,null],[13,"ExposureBiasValue","","",7,null],[13,"MaxApertureValue","","",7,null],[13,"SubjectDistance","","",7,null],[13,"MeteringMode","","",7,null],[13,"LightSource","","",7,null],[13,"Flash","","",7,null],[13,"FocalLength","","",7,null],[13,"SubjectArea","","",7,null],[13,"MakerNote","","",7,null],[13,"UserComment","","",7,null],[13,"FlashPixVersion","","",7,null],[13,"ColorSpace","","",7,null],[13,"RelatedSoundFile","","",7,null],[13,"FlashEnergy","","",7,null],[13,"FocalPlaneXResolution","","",7,null],[13,"FocalPlaneYResolution","","",7,null],[13,"FocalPlaneResolutionUnit","","",7,null],[13,"SubjectLocation","","",7,null],[13,"ExposureIndex","","",7,null],[13,"SensingMethod","","",7,null],[13,"FileSource","","",7,null],[13,"SceneType","","",7,null],[13,"CFAPattern","","",7,null],[13,"CustomRendered","","",7,null],[13,"ExposureMode","","",7,null],[13,"WhiteBalanceMode","","",7,null],[13,"DigitalZoomRatio","","",7,null],[13,"FocalLengthIn35mmFilm","","",7,null],[13,"SceneCaptureType","","",7,null],[13,"GainControl","","",7,null],[13,"Contrast","","",7,null],[13,"Saturation","","",7,null],[13,"Sharpness","","",7,null],[13,"DeviceSettingDescription","","",7,null],[13,"SubjectDistanceRange","","",7,null],[13,"ImageUniqueID","","",7,null],[13,"LensSpecification","","",7,null],[13,"LensMake","","",7,null],[13,"LensModel","","",7,null],[13,"GPSVersionID","","",7,null],[13,"GPSLatitudeRef","","",7,null],[13,"GPSLatitude","","",7,null],[13,"GPSLongitudeRef","","",7,null],[13,"GPSLongitude","","",7,null],[13,"GPSAltitudeRef","","",7,null],[13,"GPSAltitude","","",7,null],[13,"GPSTimeStamp","","",7,null],[13,"GPSSatellites","","",7,null],[13,"GPSStatus","","",7,null],[13,"GPSMeasureMode","","",7,null],[13,"GPSDOP","","",7,null],[13,"GPSSpeedRef","","",7,null],[13,"GPSSpeed","","",7,null],[13,"GPSTrackRef","","",7,null],[13,"GPSTrack","","",7,null],[13,"GPSImgDirectionRef","","",7,null],[13,"GPSImgDirection","","",7,null],[13,"GPSMapDatum","","",7,null],[13,"GPSDestLatitudeRef","","",7,null],[13,"GPSDestLatitude","","",7,null],[13,"GPSDestLongitudeRef","","",7,null],[13,"GPSDestLongitude","","",7,null],[13,"GPSDestBearingRef","","",7,null],[13,"GPSDestBearing","","",7,null],[13,"GPSDestDistanceRef","","",7,null],[13,"GPSDestDistance","","",7,null],[13,"GPSProcessingMethod","","",7,null],[13,"GPSAreaInformation","","",7,null],[13,"GPSDateStamp","","",7,null],[13,"GPSDifferential","","",7,null],[4,"IfdFormat","","Enumeration that represents the possible data formats of an IFD entry.",null,null],[13,"Unknown","","",8,null],[13,"U8","","",8,null],[13,"Ascii","","",8,null],[13,"U16","","",8,null],[13,"U32","","",8,null],[13,"URational","","",8,null],[13,"I8","","",8,null],[13,"Undefined","","",8,null],[13,"I16","","",8,null],[13,"I32","","",8,null],[13,"IRational","","",8,null],[13,"F32","","",8,null],[13,"F64","","",8,null],[4,"TagValue","","Tag value enumeration. It works as a variant type. Each value is\nactually a vector because many EXIF tags are collections of values.\nExif tags with single values are represented as single-item vectors.",null,null],[13,"U8","","Array of unsigned byte integers",9,null],[13,"Ascii","","ASCII string. (The standard specifies 7-bit ASCII, but this parser accepts UTF-8 strings.)",9,null],[13,"U16","","",9,null],[13,"U32","","",9,null],[13,"URational","","Array of `URational` structures (tuples with integer numerator and denominator)",9,null],[13,"I8","","",9,null],[13,"Undefined","","Array of bytes with opaque internal structure. Used by manufacturer-specific\ntags, SIG-specific tags, tags that contain Unicode (UCS-2) or Japanese (JIS)\nstrings (i.e. strings that are not 7-bit-clean), tags that contain \ndissimilar or variant types, etc.",9,null],[13,"I16","","",9,null],[13,"I32","","",9,null],[13,"IRational","","Array of `IRational` structures (tuples with signed integer numerator and denominator)",9,null],[13,"F32","","Array of IEEE 754 floating-points",9,null],[13,"F64","","Array of IEEE 754 floating-points",9,null],[13,"Unknown","","Array of bytes with unknown internal structure.\nThis is different from `Undefined` because `Undefined` is actually a specified\nformat, while `Unknown` is an unexpected format type. A tag of `Unknown` format\nis most likely a corrupted tag.",9,null],[5,"ifdformat_new","","Convert an IFD format code to the IfdFormat enumeration",null,{"inputs":[{"name":"u16"}],"output":{"name":"ifdformat"}}],[5,"parse_buffer","","Parse a byte buffer that should contain a TIFF or JPEG image.\nTries to detect format and parse EXIF data.",null,{"inputs":[{"name":"vec"}],"output":{"name":"exifresult"}}],[5,"read_file","","Try to read and parse an open file that is expected to contain an image",null,{"inputs":[{"name":"str"},{"name":"file"}],"output":{"name":"exifresult"}}],[5,"parse_file","","Opens an image (passed as a file name), tries to read and parse it.",null,{"inputs":[{"name":"str"}],"output":{"name":"exifresult"}}],[11,"eq","","",0,{"inputs":[{"name":"irational"},{"name":"irational"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"irational"},{"name":"irational"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"irational"}],"output":{"name":"irational"}}],[11,"value","","Floating point value (numerator divided by denominator)",0,{"inputs":[{"name":"irational"}],"output":{"name":"f64"}}],[11,"fmt","","",0,{"inputs":[{"name":"irational"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"urational"},{"name":"urational"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"urational"},{"name":"urational"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"urational"}],"output":{"name":"urational"}}],[11,"value","","Floating point value (numerator divided by denominator)",1,{"inputs":[{"name":"urational"}],"output":{"name":"f64"}}],[11,"fmt","","",1,{"inputs":[{"name":"urational"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"exifdata"}],"output":{"name":"exifdata"}}],[11,"clone","","",6,{"inputs":[{"name":"exiferrorkind"}],"output":{"name":"exiferrorkind"}}],[11,"clone","","",3,{"inputs":[{"name":"exiferror"}],"output":{"name":"exiferror"}}],[11,"clone","","",4,{"inputs":[{"name":"ifdentry"}],"output":{"name":"ifdentry"}}],[11,"eq","","",7,{"inputs":[{"name":"exiftag"},{"name":"exiftag"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"exiftag"},{"name":"exiftag"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"exiftag"}],"output":{"name":"exiftag"}}],[11,"eq","","",8,{"inputs":[{"name":"ifdformat"},{"name":"ifdformat"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"ifdformat"},{"name":"ifdformat"}],"output":{"name":"bool"}}],[11,"clone","","",8,{"inputs":[{"name":"ifdformat"}],"output":{"name":"ifdformat"}}],[11,"clone","","",5,{"inputs":[{"name":"exifentry"}],"output":{"name":"exifentry"}}],[11,"clone","","",9,{"inputs":[{"name":"tagvalue"}],"output":{"name":"tagvalue"}}],[11,"data_as_offset","","Casts IFD entry data into an offset. Not very useful for the crate client.\nThe call can't fail, but the caller must be sure that the IFD entry uses\nthe IFD data area as an offset (i.e. when the tag is a Sub-IFD tag, or when\nthere are more than 4 bytes of data and it would not fit within IFD).",4,{"inputs":[{"name":"ifdentry"}],"output":{"name":"usize"}}],[11,"size","","Returns the size of an individual element (e.g. U8=1, U16=2...). Every\nIFD entry contains an array of elements, so this is NOT the size of the\nwhole entry!",4,{"inputs":[{"name":"ifdentry"}],"output":{"name":"u8"}}],[11,"length","","Total length of the whole IFD entry (element count x element size)",4,{"inputs":[{"name":"ifdentry"}],"output":{"name":"usize"}}],[11,"in_ifd","","Returns true if data is contained within the IFD structure, false when\ndata can be found elsewhere in the image (and IFD structure contains the\ndata offset, instead of data).",4,{"inputs":[{"name":"ifdentry"}],"output":{"name":"bool"}}],[11,"copy_data","","Copies data from IFD entry section reserved for data (up to 4 bytes), or\nfrom another part of the image file (when data wouldn't fit in IFD structure).\nIn either case, the data member will contain the data of interest after\nthis call.",4,null],[11,"description","","",3,{"inputs":[{"name":"exiferror"}],"output":{"name":"str"}}],[11,"fmt","","",3,{"inputs":[{"name":"exiferror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"exiferror"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"ExifResult","","Type returned by image file parsing",null,null],[6,"ExifEntryResult","","Type resturned by lower-level parsing functions",null,null]],"paths":[[3,"IRational"],[3,"URational"],[3,"ExifData"],[3,"ExifError"],[3,"IfdEntry"],[3,"ExifEntry"],[4,"ExifErrorKind"],[4,"ExifTag"],[4,"IfdFormat"],[4,"TagValue"]]};
initSearch(searchIndex);
